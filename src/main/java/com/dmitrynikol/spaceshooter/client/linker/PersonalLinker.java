package com.dmitrynikol.spaceshooter.client.linker;

import java.io.IOException;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Set;

import org.apache.commons.io.IOUtils;

import com.google.gwt.core.ext.LinkerContext;
import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.AbstractLinker;
import com.google.gwt.core.ext.linker.Artifact;
import com.google.gwt.core.ext.linker.ArtifactSet;
import com.google.gwt.core.ext.linker.ConfigurationProperty;
import com.google.gwt.core.ext.linker.EmittedArtifact;
import com.google.gwt.core.ext.linker.LinkerOrder;
import com.google.gwt.core.ext.linker.impl.SelectionInformation;

/**
 * Linker for public path resources in the Application cache.
 * based on code from com.google.gwt.core.linker.SimpleAppCacheLinker
 * 
 * @author Dmitry Nikolaenko
 *
 */
@LinkerOrder(LinkerOrder.Order.POST)
public class PersonalLinker extends AbstractLinker {
	
	private static final String MANIFEST = "spaceshootercache.manifest";
	private static final String DEFAULT_MANIFEST_TEMPLATE = "cache.manifest.template";
	private static final String CONFIGURATION_PROPERTY = "cache.manifest";

	@Override
	public ArtifactSet link(TreeLogger logger, LinkerContext context,
			ArtifactSet artifacts, boolean onePermutation) throws UnableToCompleteException {
		
		// provides stable ordering and de-duplication of artifacts
		// that we can modify and return
		ArtifactSet artifact = new ArtifactSet(artifacts);
		
		if (onePermutation) {
			return artifact;
		}
		
		// Find all Artifacts assignable to some base type. 
		// The returned value will be a snapshot of the values 
		// in the ArtifactSet.
		if (artifact.find(SelectionInformation.class).isEmpty()) {
			logger.log(TreeLogger.INFO, "Warning: " + MANIFEST + 
					" to allow debuging. " + "Recompile before deploying your app!");
			artifacts = null;
		} else {
			// create the general cache-manifest resource for the landing page:
			artifact.add(emitLandingPageCacheManifest(context, logger, artifacts));
		}
		
		return artifact;
	}
	
	@Override
	public String getDescription() {
		return "My personal linker description";
	}
	
	/**
	 * Creates the cache-manifest resource specific for the landing page.
	 * 
	 * @param context the linker environment
	 * @param logger the tree logger to record to
	 * @param artifacts {@code null} to generate an empty cache manifest
	 */
	private Artifact<?> emitLandingPageCacheManifest(LinkerContext context, 
			TreeLogger logger, ArtifactSet artifacts)
		      throws UnableToCompleteException {
		StringBuilder publicSourcesSb = new StringBuilder();
	    StringBuilder staticResoucesSb = new StringBuilder();

	    if (artifacts != null) {
	      // Iterate over all emitted artifacts, and collect all cacheable artifacts
	      for (@SuppressWarnings("rawtypes") Artifact artifact : artifacts) {
	        if (artifact instanceof EmittedArtifact) {
	          EmittedArtifact ea = (EmittedArtifact) artifact;
	          String pathName = ea.getPartialPath();
	          if (pathName.endsWith("symbolMap") 
	              || pathName.endsWith(".xml.gz") 
	              || pathName.endsWith("rpc.log")
	              || pathName.endsWith("gwt.rpc")
	              || pathName.endsWith("manifest.txt")
	              || pathName.startsWith("rpcPolicyManifest")) {
	            // skip these resources
	          } else {
	            publicSourcesSb.append(pathName + "\n");
	          }
	        }
	      }
	      
	      String[] cacheExtraFiles = getPropertiesExtraFiles(context);
	      
	      if (cacheExtraFiles.length == 0) {
	    	  cacheExtraFiles = getCacheExtraFiles(); 
	      }

	      for (int i = 0; i < cacheExtraFiles.length; i++) {
	        staticResoucesSb.append(cacheExtraFiles[i]);
	        staticResoucesSb.append("\n");
	      }
	    }
	    
	    String cacheManifest = createApplicationCache(logger, context, publicSourcesSb, staticResoucesSb);
	    
	    logger.log(TreeLogger.INFO, "Be sure your landing page's <html> tag declares a manifest:"
	        + " <html manifest=" + context.getModuleFunctionName() + "/" + MANIFEST + "\">");

	    // Create the manifest as a new artifact and return it:
	    return emitString(logger, cacheManifest, MANIFEST);
	}
	
	/**
	 * Create application cache manifest file
	 * 
	 * @param logger the tree logger to record to
	 * @param context the linker environment
	 * @param publicSourcesSb public resources that generated by the compilation
	 * @param staticResoucesSb static resources 
	 * @return
	 * @throws UnableToCompleteException
	 */
	private String createApplicationCache(TreeLogger logger, LinkerContext context, 
			StringBuilder publicSourcesSb, StringBuilder staticResoucesSb) 
				throws UnableToCompleteException {
	    try {
	    	String manifest = IOUtils.toString(getClass().getResourceAsStream(getCacheManifestTemplate()));
	    	
	    	// replace placeholder with the real data
	    	StringBuilder sbData = new StringBuilder();
	    	sbData.append(new Date().getTime());
	    	sbData.append(".");
	    	sbData.append(Math.random());
	    	
	    	manifest = manifest.replace("$UNIQUEAPPID$", sbData.toString());
	    	manifest = manifest.replace("$STATICAPPFILES$", staticResoucesSb.toString());
	    	manifest = manifest.replace("$GENAPPFILES$", publicSourcesSb.toString());
	    	
	    	return manifest;
	    } catch(IOException ex) {
	    	logger.log(TreeLogger.ERROR, "Cound not read cache manifest file", ex);
	    	throw new UnableToCompleteException();
	    }
	}
	
	/**
	 * You should include this file into <html manifest="" \>
	 */
	protected String getCacheManifestTemplate() {
		return DEFAULT_MANIFEST_TEMPLATE;
	}
	
	/**
	 * Obtains the extra files to include in the manifest. 
	 * Ensures the returned array is not null.
	 */
	protected String[] getCacheExtraFiles() {
		String[] cacheExtraFiles = otherCachedFiles();
		return cacheExtraFiles == null ? new String[0] : 
			Arrays.copyOf(cacheExtraFiles, cacheExtraFiles.length);
	}

	/**
	 * Override this method to force the linker to also include more files in
	 * the manifest.
	 */
	protected String[] otherCachedFiles() {
		return null;
	}
	
	/**
	 * Get array of configured external properties
	 * 
	 * @param context the linker environment
	 * @return external properties
	 */
	protected String[] getPropertiesExtraFiles(LinkerContext context) {
		Set<ConfigurationProperty> properties = context.getConfigurationProperties();
		
		// if properties is empty - no external options, cache.manifest is empty!
		if (!properties.isEmpty()) {
			for (ConfigurationProperty property : properties) {
				if (property.getName().equalsIgnoreCase(CONFIGURATION_PROPERTY)) {
					List<String> props = property.getValues();
					return props.toArray(new String[0]);
				}
			}
		}
		
		return new String[0];
	}
}
